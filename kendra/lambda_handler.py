import boto3
import base64
import json
import uuid
import os
import time

kendra = boto3.client('kendra')
s3 = boto3.client('s3')

supported_operators = ["transcribevideo"]

dataplane_bucket = os.environ['DataplaneBucket']
kendra_index = os.environ['KendraIndex']

class DataPlane:
    """Helper Class for interacting with the dataplane"""

    def __init__(self):
        self.dataplane_function_name = os.environ["DataplaneHandlerArn"].split(':')[-1]
        self.lambda_client = boto3.client('lambda')
        self.lambda_invoke_object = {
            # some api uri
            "resource": "",
            # some api uri, not sure why this is needed twice
            "path": "",
            # HTTP Method
            "httpMethod": "",
            # Headers, just here so chalice formatting doesn't fail
            "headers": {
                'Content-Type': 'application/json'
            },
            # Not sure the difference between this header object and the above
            "multiValueHeaders": {},
            # Mock query string params
            "queryStringParameters": {},
            # Not sure the difference here either
            "multiValueQueryStringParameters": {},
            # Not sure what these are
            "pathParameters": {},
            # API Stage variables, again just here for chalice formatting
            "stageVariables": {},
            # request context, we generate most of this now
            "requestContext": {
                'resourcePath': '',
                'requestTime': None,
                'httpMethod': '',
                'requestId': None,
            },
            "body": {},
            "isBase64Encoded": False
        }

    def call_dataplane(self, path, resource, method, body=None, path_params=None, query_params=None):
        encoded_body = json.dumps(body)

        self.lambda_invoke_object["resource"] = resource
        self.lambda_invoke_object["path"] = path
        self.lambda_invoke_object["requestContext"]["resourcePath"] = resource
        self.lambda_invoke_object["httpMethod"] = method
        self.lambda_invoke_object["pathParameters"] = path_params
        self.lambda_invoke_object["body"] = encoded_body
        self.lambda_invoke_object["queryStringParameters"] = query_params
        if query_params is not None:
            self.lambda_invoke_object["multiValueQueryStringParameters"] = {}
            for k, v in query_params.items():
                self.lambda_invoke_object["multiValueQueryStringParameters"][k] = [v]
        else:
            self.lambda_invoke_object["multiValueQueryStringParameters"] = query_params
        self.lambda_invoke_object["requestContext"]["httpMethod"] = method
        self.lambda_invoke_object["requestContext"]["requestId"] = 'lambda_' + str(uuid.uuid4()).split('-')[-1]
        self.lambda_invoke_object["requestContext"]["requestTime"] = time.time()

        request_object = json.dumps(self.lambda_invoke_object)

        invoke_request = self.lambda_client.invoke(
            FunctionName=self.dataplane_function_name,
            InvocationType='RequestResponse',
            LogType='None',
            Payload=bytes(request_object, encoding='utf-8')
        )

        response = invoke_request["Payload"].read().decode('utf-8')

        # TODO: Do we want to do any validation on the status code or let clients parse the response as needed?
        dataplane_response = json.loads(response)
        return json.loads(dataplane_response["body"])

    def retrieve_asset_metadata(self, asset_id, operator_name=None, cursor=None):
        """
        Method to retrieve metadata from the dataplane
        :param asset_id: The id of the asset
        :param operator_name: Optional parameter for filtering response to include only data
        generated by a specific operator
        :param cursor: Optional parameter for retrieving additional pages of asset metadata
        :return: Dataplane response
        """
        if operator_name:
            path = "/metadata/{asset_id}/{operator}".format(asset_id=asset_id, operator=operator_name)
            resource = "/metadata/{asset_id}/{operator_name}"
            path_params = {"asset_id": asset_id, "operator_name": operator_name}
        else:
            path = "/metadata/{asset_id}".format(asset_id=asset_id)
            resource = "/metadata/{asset_id}"
            path_params = {"asset_id": asset_id}
        method = "GET"
        query_params = {}
        if cursor:
            query_params["cursor"] = cursor
        else:
            query_params = None
        dataplane_response = self.call_dataplane(path, resource, method, None, path_params, query_params)
        return dataplane_response


def read_json_from_s3(key):
    bucket = dataplane_bucket
    try:
        obj = s3.get_object(
            Bucket=bucket,
            Key=key
        )
    except Exception as e:
        return {"Status": "Error", "Error": e}
    else:
        results = obj['Body'].read().decode('utf-8')
        return {"Status": "Success", "Results": results}


def index_kendra(asset_id, filename, operator_name, results):
    index_status = kendra.batch_put_document(
        IndexId=kendra_index,
        Documents=[
            {
                'Id': asset_id + operator_name,
                'Title': filename,
                'Blob': results,
                'ContentType': 'PLAIN_TEXT'
                }
            ]
        )

    return index_status

def get_filename(asset):
    dataplane = DataPlane()
    asset_data = dataplane.retrieve_asset_metadata(asset)
    s3_key = asset_data['results']['S3Key']
    filename = s3_key.split('/')[-1]
    
    return filename

def process_transcribe(asset, results):
    metadata = json.loads(results)
    filename = get_filename(asset)
    transcript = metadata["results"]["transcripts"][0]['transcript']

    index_status = index_kendra(asset, filename, 'transcript', transcript)

    print(index_status)


def lambda_handler(event, context):
    print("Received event:", event)

    action = None
    asset_id = None
    payload = None

    for record in event['Records']:
        # Kinesis data is base64 encoded so decode here
        try:
            asset_id = record['kinesis']['partitionKey']
            payload = json.loads(base64.b64decode(record["kinesis"]["data"]))
        except Exception as e:
            print("Error decoding kinesis event", e)
        else:
            print("Decoded payload for asset:", asset_id)
            try:
                action = payload['Action']
            except KeyError as e:
                print("Missing action type from kinesis record:", e)
            else:
                print("Attempting the following action:", action)

        if action is None:
            print("Unable to determine action type")
        elif action == "INSERT":
            print("Not handling INSERT actions")
        elif action == "MODIFY":
            try:
                operator = payload['Operator']
                s3_pointer = payload['Pointer']
                workflow = payload['Workflow']
            except KeyError as e:
                print("Missing required keys in kinesis payload:", e)
            else:
                # Read in json metadata from s3
                metadata = read_json_from_s3(s3_pointer)
                if metadata["Status"] == "Success":
                    print("Retrieved {operator} metadata from s3, inserting into Elasticsearch".format(operator=operator))
                    operator = operator.lower()
                    # Route event to process method based on the operator type in the event.
                    # These names are the lowercase version of OPERATOR_NAME defined in /source/operators/operator-library.yaml
                    if operator in supported_operators:
                        if operator == "transcribevideo":
                            process_transcribe(asset_id, metadata["Results"])
                    else:
                        print("We do not store {operator} results".format(operator=operator))
                else:
                    print("Unable to read metadata from s3: {e}".format(e=metadata["Error"]))
        elif action == "REMOVE":
            print("Not handling REMOVE actions")